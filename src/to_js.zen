// to_js.zen - Zen â†’ JavaScript transpiler
// Written in Zen using compile-time AST introspection.
//
// Usage:
//   { meta } = @std
//   ast = meta.parse(read_file("app.zen"))
//   js = emit_program(ast)

{ meta } = @std

// Walk an AST node and dispatch to the appropriate emitter
to_js = (node: meta.ASTNode) String {
    node.variant_name() ?
        | "Program"            { return emit_program(node) }
        | "Function"           { return emit_function(node) }
        | "Struct"             { return emit_struct(node) }
        | "Enum"               { return emit_enum(node) }
        | "Integer32"          { return "${node.value}" }
        | "Integer64"          { return "${node.value}n" }
        | "Float32"            { return "${node.value}" }
        | "Float64"            { return "${node.value}" }
        | "Boolean"            { return node.value ? | true { "true" } | false { "false" } }
        | "String"             { return "\"${node.value}\"" }
        | "Identifier"         { return node.name }
        | "None"               { return "null" }
        | "Some"               { return to_js(node.inner) }
        | "BinaryOp"           { return emit_binary_op(node) }
        | "FunctionCall"       { return emit_call(node) }
        | "MethodCall"         { return emit_method_call(node) }
        | "MemberAccess"       { return to_js(node.object) + ".${node.member}" }
        | "ArrayLiteral"       { return emit_list(node.elements, "[", "]") }
        | "ArrayIndex"         { return to_js(node.array) + "[" + to_js(node.index) + "]" }
        | "StructLiteral"      { return "new ${node.name}(" + emit_list(node.fields, "", ")") }
        | "StringInterpolation" { return emit_template_literal(node) }
        | "QuestionMatch"      { return emit_match(node) }
        | "Closure"            { return emit_closure(node) }
        | "Block"              { return emit_block(node) }
        | "Return"             { return "return " + to_js(node.expr) }
        | "EnumLiteral"        { return "{ tag: \"${node.variant}\" }" }
        | _                    { return "/* unsupported: ${node.variant_name()} */" }
}
